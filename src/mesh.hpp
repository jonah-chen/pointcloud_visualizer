
#pragma once

#include "camera.hpp"
#include <glm/glm.hpp>
#include <open3d/Open3D.h>

using o3d_PointCloud = open3d::geometry::TriangleMesh;

struct PNC
{
    glm::vec3 p;
    glm::vec3 n;
    glm::vec3 c;
};

struct m_PointCloud 
{
    using V = std::vector<PNC>;
    using F = std::vector<Eigen::Vector3i>;
    V v;
    F f;
    m_PointCloud(size_t n) : v(n), f(n) {}
    m_PointCloud(size_t n, F &&f) : v(n), f(std::move(f)) {}
    inline size_t size() const { return v.size(); }
    inline const PNC *vertices() const { return v.data(); }
    inline PNC *vertices() { return v.data(); }
    inline const unsigned int *indices() const { return (const unsigned int *)f.data(); }
    inline unsigned int *indices() { return (unsigned int *)f.data(); }
};

/**
 * Load a meshed pointcloud generated using the BPA algorithm from a file.
 * The original points are also required to maintain order of the points for
 * the applcation of masks or bounding boxes.
 * 
 * @param mesh The mesh generated by the BPA algorithm. 
 * @param exchange_yz Whether the y and z coordinates are exchanged relative to
 * the S3DIS dataset.
 * @return o3d_PointCloud The meshed and ordered pointcloud. 
 */
m_PointCloud load_mesh(const std::string &mesh, bool exchange_yz);
